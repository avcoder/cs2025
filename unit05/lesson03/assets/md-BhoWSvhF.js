import{b as a,o as i,w as r,g as t,ac as l,v as s,x as c,C as o}from"./modules/vue-Dic_Rs6a.js";import{I as m}from"./slidev/default-e8xCuU_1.js";import{u as d,f as p}from"./slidev/context-Ddz-tmlJ.js";import"./index-66FePm2m.js";import"./modules/shiki-BH44VRg7.js";const O={__name:"slides.md__slidev_14",setup(f){const{$clicksContext:n,$frontmatter:u}=d();return n.setup(),(b,e)=>(i(),a(m,s(c(o(p)(o(u),13))),{default:r(()=>e[0]||(e[0]=[t("h1",null,"Big O for Recursive Fibonacci using Memoization",-1),t("table",null,[t("thead",null,[t("tr",null,[t("th",null,"Operation"),t("th",null,"Time")])]),t("tbody",null,[t("tr",null,[t("td",null,[l("First-time compute "),t("code",null,"fib(n)")]),t("td",null,"O(n)")]),t("tr",null,[t("td",null,"Subsequent lookup"),t("td",null,"O(1)")])])],-1),t("ul",null,[t("li",null,[l("Memoization avoids recomputing the same values, but: "),t("ul",null,[t("li",null,"You still need to compute each value from fib(0) up to fib(n) at least once."),t("li",null,"The first time fib(n) is called, it recursively computes fib(n-1) and fib(n-2) — but after those are cached, they’re O(1) to retrieve.")])])],-1)])),_:1},16))}};export{O as default};
