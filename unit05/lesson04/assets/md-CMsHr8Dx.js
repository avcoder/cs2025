import{b as u,o as r,w as s,g as l,v as a,x as d,C as n}from"./modules/vue-Dic_Rs6a.js";import{I as i}from"./slidev/default-DbhO1z7S.js";import{u as c,f as m}from"./slidev/context-DYieDcrn.js";import"./index-CSkZBxzi.js";import"./modules/shiki-BH44VRg7.js";const y={__name:"slides.md__slidev_26",setup(p){const{$clicksContext:e,$frontmatter:o}=c();return e.setup(),(f,t)=>(r(),u(i,a(d(n(m)(n(o),25))),{default:s(()=>t[0]||(t[0]=[l("h1",null,"Big O for Dijkstra’s Algorithm",-1),l("table",null,[l("thead",null,[l("tr",null,[l("th",null,[l("strong",null,"Data Structure Used")]),l("th",null,[l("strong",null,"Time Complexity")]),l("th",null,[l("strong",null,"Space Complexity")]),l("th",null,[l("strong",null,"Notes")])])]),l("tbody",null,[l("tr",null,[l("td",null,[l("strong",null,"Adjacency List + Min Heap")]),l("td",null,[l("code",null,"O((V + E) * log V)")]),l("td",null,[l("code",null,"O(V)")]),l("td",null,"✅ Most efficient for sparse graphs")]),l("tr",null,[l("td",null,[l("strong",null,"Adjacency List + Array")]),l("td",null,[l("code",null,"O(V²)")]),l("td",null,[l("code",null,"O(V)")]),l("td",null,"❌ Slower, used in simple implementations")]),l("tr",null,[l("td",null,[l("strong",null,"Adjacency Matrix")]),l("td",null,[l("code",null,"O(V²)")]),l("td",null,[l("code",null,"O(V²)")]),l("td",null,"⚠️ Good for dense graphs, but uses more space")])])],-1),l("ul",null,[l("li",null,"V: Number of vertices (nodes)"),l("li",null,"E: Number of edges (connections between nodes)"),l("li",null,"log V: Comes from operations on the min-heap (priority queue)")],-1)])),_:1},16))}};export{y as default};
