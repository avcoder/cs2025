import{b as s,o as i,w as r,g as e,ac as t,v as h,x as d,C as n}from"./modules/vue-Dic_Rs6a.js";import{I as u}from"./slidev/default-DbhO1z7S.js";import{u as c,f as m}from"./slidev/context-DYieDcrn.js";import"./index-CSkZBxzi.js";import"./modules/shiki-BH44VRg7.js";const w={__name:"slides.md__slidev_29",setup(f){const{$clicksContext:o,$frontmatter:a}=c();return o.setup(),(p,l)=>(i(),s(u,h(d(n(m)(n(a),28))),{default:r(()=>l[0]||(l[0]=[e("h1",null,"Pseudocode of Dijkstra’s Algorithm (v.2)",-1),e("ol",null,[e("li",null,[t("Start by assigning a distance value to every node: "),e("ul",null,[e("li",null,"Set the distance to the starting node as 0."),e("li",null,"Set the distance to all other nodes as infinity (∞) because we haven’t found a path to them yet.")])]),e("li",null,"Create a list (or priority queue) of all the nodes that need to be checked."),e("li",null,[t("While there are still nodes to check: "),e("ul",null,[e("li",null,'a. Pick the node with the smallest distance value (let’s call this the "current node").'),e("li",null,"b. Look at all the neighboring nodes connected to the current node."),e("li",null,[t("c. For each neighbor: "),e("ul",null,[e("li",null,"Calculate the distance from the start node to this neighbor by going through the current node."),e("li",null,[t("If this new path is shorter than the distance we had recorded before: "),e("ul",null,[e("li",null,"Update the shortest distance for that neighbor.")])])])]),e("li",null,'d. Once done checking all neighbors, mark the current node as "visited" so we don’t check it again.')])]),e("li",null,"When all nodes have been visited, the shortest distance to each node from the start is known.")],-1)])),_:1},16))}};export{w as default};
